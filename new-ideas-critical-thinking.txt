24-12-25

2:22pm
    i still dont think my solution to part 1 is fpga friendly
    yes it is to an extent, i hv removed software oriented if-else nested loops and brought
    convolution style solution
    but those negative indices and replacing the character comparisons to binary can bring better
    fpga synthesis
    dynamic checking feels bad
2:45 pm
    did some research and found this, i have also attached ss for future reference

    // RESEARCH, GOOGLE
    Dynamic checking is generally considered "bad" for FPGAs primarily because it
    introduces significant performance overhead, increases power consumption,
    and consumes valuable logic resources that are better utilized for the core application.
    The fundamental nature of FPGAs is optimized for static, parallel hardware execution,
    not the sequential, conditional operations typical of dynamic software checking. 
    // CHECK THIS //

    if ((i+oi)>=0&&(i+oi)<depth && (j+oj)>=0&&(j+oj)<width) begin 
    
    i hate this above line
    maybe i can choose a wire type to keep it static

    to sum up
    1. i dont want negative indices --- > for (oi=-1;oi <= 1;oi =oi+1) be
    2. change all those dynamic checks to static wires
    4. @ to 1 and . to 0
    5. check once again for latches inferred

    so my idea is to make some net elements for each neighbour
    if the neighbour is @ it will be set to 

3:45pm: 
    edits were made in the design 4 file and made the design more hardware friendly

12:05 AM:
    so software approach to part 2 seems dumb

25-12-25
10:29AM:
    (grid_in) --> remove_accessible --> (grid_out, removed_count, any_removed)
    this is going to be my formula
    
4:10 pm:
    try pipelining
    for part 1 now its fully combinational and deterministic, but it might take a large area

26-12-25
11:51 AM:
    ye so i had this idea when i was sleeping
    we can have a flag reg to see if process is over
    like smtg which says its done no more acceessible rolls of paper
    ok so i added smtg extra any_removed flag
    i can just use remoeved == 0

2:26 pm:
    i ran the example given in aoc and i hit bugs
    TOTAL REMOVED = 13
    got this instead of 43
    im going to test part 1 first

2:38 pm:
    yesss
    part 1 has passed the example test case
    design.sv:16: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:29: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:30: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:31: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:32: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:33: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:34: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:35: warning: @* is sensitive to all 10 words in array 'mat'.
    design.sv:36: warning: @* is sensitive to all 10 words in array 'mat'.
    ACCESSIBLE COUNT = 13
    testbench.sv:32: $finish called at 1000 (1ps)

    warnings are nothin we want that for procedural blocks

2:56 pm:
    now ill check whats the diff between my part 2 and aoc part 2